// The compiler needs direct access to the template class implementation or
// it will give symbol lookup errors. The solution is to have the code in an
// impl file and include such file in the .h
/*
 * VoxelDataset.cpp
 *
 *  Created on: 26 Jun 2015
 *      Author: gdp24
 */

#include <cassert>
#include <cmath>

template<typename DataT, typename TreeT>
VoxelDataset<DataT, TreeT>::VoxelDataset(const DataT& background) :
		block(openvdb::Grid < TreeT > ::create(background)), accessor(
				block->getAccessor()), interpolation_mode(TRILINEAR), interpolate_function(
				std::mem_fn(
						&VoxelDataset<DataT, TreeT>::trilinear_interpolation)) {
	resize(0, 0, 0);
}

template<typename DataT, typename TreeT>
VoxelDataset<DataT, TreeT>::VoxelDataset(unsigned width, unsigned height,
		unsigned depth, const DataT& background) :
		block(openvdb::Grid < TreeT > ::create(background)), accessor(
				block->getAccessor()), interpolation_mode(TRILINEAR), interpolate_function(
				std::mem_fn(
						&VoxelDataset<DataT, TreeT>::trilinear_interpolation)) {
	resize(width, height, depth);
}

template<typename DataT, typename TreeT>
VoxelDataset<DataT, TreeT>::VoxelDataset(const VoxelDataset& other) :
		block(openvdb::Grid < TreeT > ::create(other.block->background())), accessor(
				block->getAccessor()), interpolation_mode(TRILINEAR), interpolate_function(
				std::mem_fn(
						&VoxelDataset<DataT, TreeT>::trilinear_interpolation)) {
	resize(other.width, other.height, other.depth);
	setInterpolationMode(other.interpolation_mode);
	block = other.block->deepCopy();
}

template<typename DataT, typename TreeT>
VoxelDataset<DataT, TreeT>& VoxelDataset<DataT, TreeT>::operator =(
		const VoxelDataset<DataT, TreeT>& other) {

	if (this == &other) {
		return *this;
	}

	clear();
	resize(other.width, other.height, other.depth);
	setInterpolationMode(other.interpolation_mode);
	block = other.block->deepCopy();

	return *this;
}

template<typename DataT, typename TreeT>
void VoxelDataset<DataT, TreeT>::clear() {
	resize(0, 0, 0);
	block->clear();
	accessor.clear();
}

template<typename DataT, typename TreeT>
void VoxelDataset<DataT, TreeT>::resize(unsigned width, unsigned height,
		unsigned depth) {
	this->width = width;
	this->height = height;
	this->depth = depth;
	count = width * height * depth;

	if (count > MAX_DATASET_SIZE) {
		mi_fatal(
				"Voxel dataset, max size is %d but tried to initialise with %d",
				MAX_DATASET_SIZE, count);
	}
}

template<typename DataT, typename TreeT>
float VoxelDataset<DataT, TreeT>::getMemFootPrint() const {
	return block->memUsage() * 1e-6; // Size in Mega Bytes
}

template<typename DataT, typename TreeT>
void VoxelDataset<DataT, TreeT>::pre_cach_all() {
	accessor.clear();
	for (unsigned i = 0; i < width; i++) {
		for (unsigned j = 0; j < height; j++) {
			for (unsigned k = 0; k < depth; k++) {
				accessor.getValue(openvdb::Coord(i, j, k));
			}
		}
	}
}

template<typename DataT, typename TreeT>
typename VoxelDataset<DataT, TreeT>::Accessor VoxelDataset<DataT, TreeT>::get_accessor() const {
	return block->getAccessor();
}

template<typename DataT, typename TreeT>
DataT VoxelDataset<DataT, TreeT>::get_voxel_value(float x, float y,
		float z) const {
	return get_voxel_value(x, y, z, accessor);
}

template<typename DataT, typename TreeT>
DataT VoxelDataset<DataT, TreeT>::get_voxel_value(float x, float y, float z,
		const Accessor& accessor) const {
	assert(
			((int ) (z + .5)) * depth * height + ((int ) (y + .5)) * height
					+ ((int ) (x + .5)) < MAX_DATASET_SIZE);
	return interpolate_function(this, x, y, z, accessor);
}

template<typename DataT, typename TreeT>
DataT VoxelDataset<DataT, TreeT>::get_fitted_voxel_value(const miVector *p,
		const miVector *min_point, const miVector *max_point) const {
	return get_fitted_voxel_value(p, min_point, max_point, accessor);
}

template<typename DataT, typename TreeT>
DataT VoxelDataset<DataT, TreeT>::get_fitted_voxel_value(const miVector *p,
		const miVector *min_point, const miVector *max_point,
		const Accessor& accessor) const {
	float x, y, z;
	x = (float) fit(p->x, min_point->x, max_point->x, 0, width - 1);
	y = (float) fit(p->y, min_point->y, max_point->y, 0, height - 1);
	z = (float) fit(p->z, min_point->z, max_point->z, 0, depth - 1);
	assert(x >= 0 && x < width && y >= 0 && y < height && z >= 0 && z < depth);
	return get_voxel_value(x, y, z, accessor);
}

template<typename DataT, typename TreeT>
const DataT& VoxelDataset<DataT, TreeT>::get_voxel_value(unsigned x, unsigned y,
		unsigned z) const {
	return get_voxel_value(x, y, z, accessor);
}

template<typename DataT, typename TreeT>
const DataT& VoxelDataset<DataT, TreeT>::get_voxel_value(unsigned x, unsigned y,
		unsigned z, const Accessor& accessor) const {
	assert(x >= 0 && x < width && y >= 0 && y < height && z >= 0 && z < depth);
	return accessor.getValue(openvdb::Coord(x, y, z));
}

template<typename DataT, typename TreeT>
void VoxelDataset<DataT, TreeT>::set_voxel_value(unsigned x, unsigned y,
		unsigned z, const DataT& val) {
	assert(x >= 0 && x < width && y >= 0 && y < height && z >= 0 && z < depth);
	accessor.setValue(openvdb::Coord(x, y, z), val);
}

template<typename DataT, typename TreeT>
int VoxelDataset<DataT, TreeT>::getWidth() const {
	return width;
}

template<typename DataT, typename TreeT>
int VoxelDataset<DataT, TreeT>::getDepth() const {
	return depth;
}

template<typename DataT, typename TreeT>
int VoxelDataset<DataT, TreeT>::getHeight() const {
	return height;
}

template<typename DataT, typename TreeT>
int VoxelDataset<DataT, TreeT>::getTotal() const {
	return count;
}

template<typename DataT, typename TreeT>
typename VoxelDataset<DataT, TreeT>::InterpolationMode VoxelDataset<DataT, TreeT>::getInterpolationMode() const {
	return interpolation_mode;
}

template<typename DataT, typename TreeT>
void VoxelDataset<DataT, TreeT>::setInterpolationMode(
		InterpolationMode interpolation_mode) {
	if (this->interpolation_mode == interpolation_mode) {
		return;
	}
	this->interpolation_mode = interpolation_mode;
	switch (interpolation_mode) {
	case TRUNCATE: {
		interpolate_function = std::mem_fn(
				&VoxelDataset<DataT, TreeT>::no_interpolation);
		break;
	}
	case TRILINEAR: {
		interpolate_function = std::mem_fn(
				&VoxelDataset<DataT, TreeT>::trilinear_interpolation);
		break;
	}
	}
}

template<typename DataT, typename TreeT>
double VoxelDataset<DataT, TreeT>::fit(double v, double oldmin, double oldmax,
		double newmin, double newmax) const {
	return newmin + ((v - oldmin) / (oldmax - oldmin)) * (newmax - newmin);
}

template<typename DataT, typename TreeT>
DataT VoxelDataset<DataT, TreeT>::trilinear_interpolation(float x, float y,
		float z, const Accessor& accessor) const {
	// Round down the indices
	int x0, y0, z0;
	x0 = int(x);
	y0 = int(y);
	z0 = int(z);

	// TODO Tricubic interpolation would yield better results at a higher
	// computational expense
	// https://en.wikipedia.org/wiki/Tricubic_interpolation

	// Got enough voxels around to interpolate
	// Do simple triliniear interpolation
	// http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/interpolation/trilinear-interpolation/
	if (x0 < width - 2 && y0 < height - 2 && z0 < depth - 2) {
		int x1, y1, z1;
		float tx, ty, tz;

		x1 = x0 + 1;
		y1 = y0 + 1;
		z1 = z0 + 1;

		// [0..1] interpolation value
		tx = x - x0;
		ty = y - y0;
		tz = z - z0;

		const DataT& c000 = accessor.getValue(openvdb::Coord(x0, y0, z0));
		const DataT& c001 = accessor.getValue(openvdb::Coord(x0, y0, z1));
		const DataT& c010 = accessor.getValue(openvdb::Coord(x0, y1, z0));
		const DataT& c011 = accessor.getValue(openvdb::Coord(x0, y1, z1));
		const DataT& c100 = accessor.getValue(openvdb::Coord(x1, y0, z0));
		const DataT& c101 = accessor.getValue(openvdb::Coord(x1, y0, z1));
		const DataT& c110 = accessor.getValue(openvdb::Coord(x1, y1, z0));
		const DataT& c111 = accessor.getValue(openvdb::Coord(x1, y1, z1));

		DataT c0 = bilinear_interp(tx, ty, c000, c100, c010, c110);
		DataT c1 = bilinear_interp(tx, ty, c001, c101, c011, c111);

		return linear_interp(tz, c0, c1);
	} else {
		return accessor.getValue(
				openvdb::Coord((int) (x + .5), (int) (y + .5), (int) (z + .5)));
	}
}

template<typename DataT, typename TreeT>
DataT VoxelDataset<DataT, TreeT>::no_interpolation(float x, float y, float z,
		const Accessor& accessor) const {
	return accessor.getValue(
			openvdb::Coord((int) (x + .5), (int) (y + .5), (int) (z + .5)));
}
